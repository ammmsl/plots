<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Summer Island Load Variation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.24.1/plotly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            gap: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            width: 250px;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .plot-container {
            flex: 1;
            min-height: 600px;
        }
        .group {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        .group-header {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            cursor: pointer;
            user-select: none;
        }
        .group-header:hover {
            color: #007bff;
        }
        .group-items {
            margin-left: 10px;
        }
        .checkbox-item {
            margin: 5px 0;
        }
        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
        }
        .checkbox-item label {
            cursor: pointer;
            font-size: 14px;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .select-all-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }
        .select-all-btn:hover {
            background-color: #0056b3;
        }
        .deselect-all-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .deselect-all-btn:hover {
            background-color: #545b62;
        }
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
        }
        
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 400px;
            max-width: 500px;
            z-index: 1001;
        }
        
        .popup h3, .popup h4 {
            margin-top: 0;
            color: #333;
        }
        
        .popup hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 15px 0;
        }
        
        .popup p {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .popup-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        
        .popup-close:hover {
            color: #000;
        }
        #load-status {
			font-size: 16px;
			display: inline-block;
			width: 250px; /* Fixed width to accommodate longest text */
			text-align: center;
		}
    </style>
</head>
<body>
<!--     <h1>Summer Island Load Variation</h1> -->
    <div class="container">
        <div class="controls">
            <div style="margin-bottom: 15px;">
                <button class="select-all-btn" onclick="selectAll()">Select All</button>
                <button class="deselect-all-btn" onclick="deselectAll()">Deselect All</button>
            </div>
            <div style="margin-bottom: 15px; border-top: 1px solid #ddd; padding-top: 10px;">
                <label style="font-weight: bold; margin-bottom: 5px; display: block;">Interaction Mode:</label>
                <div style="margin: 5px 0;">
                    <input type="radio" id="mode-points" name="interaction-mode" value="points" checked>
                    <label for="mode-points">Point Comparison</label>
                </div>
                <div style="margin: 5px 0;">
                    <input type="radio" id="mode-area" name="interaction-mode" value="area">
                    <label for="mode-area">Area Calculation</label>
                </div>
            </div>           
            <div class="group">
                <div class="group-header" onclick="toggleGroup('load')">
                    <input type="checkbox" id="group-load" onchange="toggleGroupSelection('load')" checked>
                    üìä Load
                </div>
                <div class="group-items" id="load-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="present-load" class="group-load" checked>
                        <label for="present-load">Present Load</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="predicted-load" class="group-load" checked>
                        <label for="predicted-load">Predicted Load</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('solar')">
                    <input type="checkbox" id="group-solar" onchange="toggleGroupSelection('solar')" checked>
                    ‚òÄÔ∏è Solar
                </div>
                <div class="group-items" id="solar-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="solar-power" class="group-solar" checked>
                        <label for="solar-power">Solar Power</label>
                    </div>
					<div class="checkbox-item">
                        <input type="checkbox" id="solar-power-2" class="group-solar">
                        <label for="solar-power-2">Solar Power 2</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="diesel-demand" class="group-solar" checked>
                        <label for="diesel-demand">Diesel Demand</label>
                    </div>
					<div class="checkbox-item">
                        <input type="checkbox" id="diesel-demand-2" class="group-solar" checked>
                        <label for="diesel-demand">Diesel Demand 2</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('current')">
                    <input type="checkbox" id="group-current" onchange="toggleGroupSelection('current')">
                    üîß Current Configurations
                </div>
                <div class="group-items" id="current-items">
					<div class="checkbox-item">
						<input type="checkbox" id="650-508" class="group-current">
						<label for="650-508">650+508</label>
					</div>	
                    <div class="checkbox-item">
                        <input type="checkbox" id="650-460" class="group-current">
                        <label for="650-460">650+460</label>
                    </div>
					<div class="checkbox-item">
						<input type="checkbox" id="508-460" class="group-current">
						<label for="508-460">508+460</label>
					</div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="650-160" class="group-current">
                        <label for="650-160">650+160</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="508-160" class="group-current">
                        <label for="508-160">508+160</label>
                    </div>                    
					<div class="checkbox-item">
                        <input type="checkbox" id="460-160" class="group-current">
                        <label for="460-160">460+160</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="650" class="group-current">
                        <label for="650">650</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="508" class="group-current">
                        <label for="508">508</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="460" class="group-current">
                        <label for="460">460</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="160" class="group-current">
                        <label for="160">160</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('200kW')">
                    <input type="checkbox" id="group-200kW" onchange="toggleGroupSelection('200kW')">
                    ‚ö° 200kW Unit
                </div>
                <div class="group-items" id="200kW-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="650-200vp" class="group-200kW">
                        <label for="650-200vp">650+200(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="508-200vp" class="group-200kW">
                        <label for="508-200vp">508+200(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="460-200vp" class="group-200kW">
                        <label for="460-200vp">460+200(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="160-200vp" class="group-200kW">
                        <label for="160-200vp">160+200(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="200kW" class="group-200kW">
                        <label for="200kW">200kW</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('520kW')">
                    <input type="checkbox" id="group-520kW" onchange="toggleGroupSelection('520kW')">
                    ‚ö° 520kW Unit
                </div>
                <div class="group-items" id="520kW-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="650-520vp" class="group-520kW">
                        <label for="650-520vp">650+520(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="508-520vp" class="group-520kW">
                        <label for="508-520vp">508+520(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="460-520vp" class="group-520kW">
                        <label for="460-520vp">460+520(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="160-520vp" class="group-520kW">
                        <label for="160-520vp">160+520(VP)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="520kW" class="group-520kW">
                        <label for="520kW">520kW</label>
                    </div>
                </div>
            </div>
        </div>
        <div class="plot-container">
            <div id="plot" style="width: 100%; height: 600px;"></div>
			<div style="margin-bottom: 15px; border-top: 1px solid #ddd; padding-top: 10px;">
				<label style="font-weight: bold; margin-bottom: 8px; display: block;">Generator Load Level:</label>
				<div style="position: relative; margin: 10px 0;">
					<input type="range" id="load-slider" min="25" max="100" value="75" step="5" 
						   style="width: 100%; height: 8px; background: linear-gradient(to right, #ff4444 0%, #ff4444 28%, #ffaa44 28%, #ffaa44 68%, #44aa44 68%, #44aa44 72%, #4444ff 72%, #4444ff 100%);">
					<div style="display: flex; justify-content: space-between; font-size: 11px; margin-top: 5px;">
						<span style="color: #ff4444;">25% Damaging</span>
						<span style="color: #ffaa44;">40% Min Safe</span>
						<span style="color: #44aa44; font-weight: bold;">75% Optimal</span>
						<span style="color: #4444ff;">100% Max</span>
					</div>
				</div>
				<div style="text-align: center; font-weight: bold; margin: 5px 0;">
					Current Load: <span id="load-value" style="color: #44aa44;">75%</span>
				</div>
				<div style="text-align: center; margin: 2px 0;">
					<span id="load-status" style="font-size: 16px; color: #44aa44;">Optimal Efficiency</span>
				</div>
			</div>
        </div>
        <div id="popup-overlay" class="popup-overlay" onclick="closePopup()">
            <div class="popup" onclick="event.stopPropagation()">
                <button class="popup-close" onclick="closePopup()">&times;</button>
                <div id="popup-content"></div>
            </div>
        </div>
    </div>

    <script>
        // Data
		const generatorConfigs = {
			'650+508': { units: [650, 508] }, 
			'650+460': { units: [650, 460] },
			'508+460': { units: [508, 460] },
			'650': { units: [650] },
			'650+160': { units: [650, 160] },
			'508+160': { units: [508, 160] },
			'460+160': { units: [460, 160] }, 
			'508': { units: [508] },
			'460': { units: [460] },
			'160': { units: [160] },
			'200kW': { units: [200] },
			'520kW': { units: [520] },
			'460+200(VP)': { units: [460, 200] },
			'650+200(VP)': { units: [650, 200] },
			'160+200(VP)': { units: [160, 200] },
			'508+200(VP)': { units: [508, 200] },
			'460+520(VP)': { units: [460, 520] },
			'650+520(VP)': { units: [650, 520] },
			'160+520(VP)': { units: [160, 520] },
			'508+520(VP)': { units: [508, 520] }
		};
		
		function calculateGeneratorOutput(config, loadPercentage = 100) {
			const totalCapacity = config.units.reduce((sum, capacity) => sum + capacity, 0);
			const outputValue = totalCapacity * (loadPercentage / 100);
			return new Array(25).fill(outputValue);
		}
		function updateGeneratorData(loadPercentage) {
			Object.keys(generatorConfigs).forEach(configName => {
				data[configName] = calculateGeneratorOutput(generatorConfigs[configName], loadPercentage);
			});
		}
		
        const data = {
            time: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],
            'Present Load': [230, 237.1555765, 258.1346652, 291.507576, 335, 385.6480005, 440, 494.3519995, 545, 588.492424, 621.8653348, 642.8444235, 650, 642.8444235, 621.8653348, 588.492424, 545, 494.3519995, 440, 385.6480005, 335, 291.507576, 258.1346652, 237.1555765, 230],
            'Predicted Load': [272.728913,264.5,272.728913,296.854865,335.2337123,385.25,443.6602006,506,568.5047994,626.75,676.7662877,715.145135,739.271087,747.5,739.271087,715.145135,676.7662877,626.75,568.5047994,506,443.6602006,385.25,335.2337123,296.854865,272.728913],
            'Solar Power': [0,0,0,0,0,0,0,182.8401262,353.22,499.5285145,611.7949862,682.3686407,706.44,682.3686407,611.7949862,499.5285145,353.22,182.8401262,8.65494E-14,0,0,0,0,0,0],
			'Solar Power 2': [0,0,0,0,0,0,0,400.694587,774.0825,1094.71797,1340.750219,1495.412557,1548.165,1495.412557,1340.750219,1094.71797,774.0825,400.694587,1.89673E-13,0,0,0,0,0,0], 
            'Diesel Demand': [237.2,230.0,237.2,258.1,291.5,335.0,385.6,257.2,141.1,45.5,-23.3,-60.5,-63.6,-32.4,31.0,122.3,235.3,362.2,494.4,440.0,385.6,335.0,291.5,258.1,237.2],
        };
        data['Predicted Load'] = data['Present Load'].map(load => load * 1.15);
        data['Diesel Demand'] = data['Present Load'].map((load, index) => load - data['Solar Power'][index]);
		data['Diesel Demand 2'] = data['Present Load'].map((load, index) => load - data['Solar Power 2'][index]);
		
		// Generator data will be populated by updateGeneratorData() function
		
        let selectedPoints = [];
        let selectedAreaPoints = [];
        let areaPopupVisible = false;        
        let interactionMode = 'points'; // Default mode
        
        // Add mode change listener
        function updateInteractionMode() {
            const pointsMode = document.getElementById('mode-points');
            const areaMode = document.getElementById('mode-area');
            
            if (pointsMode.checked) {
                interactionMode = 'points';
            } else if (areaMode.checked) {
                interactionMode = 'area';
            }
            
            // Reset selections when mode changes
            selectedPoints = [];
            selectedAreaPoints = [];
            closePopup();
        }
		// Add slider
		function updateLoadSlider() {
			const loadValue = parseInt(document.getElementById('load-slider').value);
			document.getElementById('load-value').textContent = loadValue + '%';
			
			// Update status message and color
			const statusElement = document.getElementById('load-status');
			const valueElement = document.getElementById('load-value');
			
			if (loadValue < 40) {
				statusElement.textContent = 'Damaging Operation';
				statusElement.style.color = '#ff4444';
				valueElement.style.color = '#ff4444';
			} else if (loadValue < 75) {
				statusElement.textContent = 'Acceptable Operation';
				statusElement.style.color = '#ffaa44';
				valueElement.style.color = '#ffaa44';
			} else if (loadValue === 75) {
				statusElement.textContent = 'Optimal Efficiency';
				statusElement.style.color = '#44aa44';
				valueElement.style.color = '#44aa44';
			} else {
				statusElement.textContent = 'Higher Load Operation';
				statusElement.style.color = '#4444ff';
				valueElement.style.color = '#4444ff';
			}
			
			updateGeneratorData(loadValue);
			createPlot();
		}
        // Add event listener after plot creation
        function addClickListener() {
            document.getElementById('plot').on('plotly_click', handlePlotClick);
        }
        
        function handlePlotClick(data) {
            const point = data.points[0];
            const clickedPoint = {
                x: point.x,
                y: point.y,
                seriesName: point.data.name
            };
            
            if (interactionMode === 'points') {
                handlePointSelection(clickedPoint);
            } else if (interactionMode === 'area') {
                handleAreaSelection(data);
            }
        }
        
        function handlePointSelection(clickedPoint) {
            selectedPoints.push(clickedPoint);
            
            if (selectedPoints.length === 2) {
                // Check if both points have same x value for point difference
                if (selectedPoints[0].x === selectedPoints[1].x) {
                    showDifferencePopup();
                } else {
                    // Show message that points need same X coordinate
                    alert("For point comparison, please select two points at the same time (X-coordinate). Selected points will be reset.");
                    selectedPoints = []; // Reset selection
                }
            } else if (selectedPoints.length > 2) {
                selectedPoints = [clickedPoint]; // Start new selection
            }
        }
        
        function handleAreaSelection(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // More helpful error message
                alert("No enclosed region found. Try clicking between intersecting curves or in areas where multiple lines create enclosed spaces.");
            }
        }
        
        function handlePointSelection(clickedPoint) {
            selectedPoints.push(clickedPoint);
            
            if (selectedPoints.length === 2) {
                // Check if both points have same x value for point difference
                if (selectedPoints[0].x === selectedPoints[1].x) {
                    showDifferencePopup();
                } else {
                    // Show message that points need same X coordinate
                    alert("For point comparison, please select two points at the same time (X-coordinate). Selected points will be reset.");
                    selectedPoints = []; // Reset selection
                }
            } else if (selectedPoints.length > 2) {
                selectedPoints = [clickedPoint]; // Start new selection
            }
        }
        
        function handleAreaSelection(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // More helpful error message
                alert("No enclosed region found. Try clicking between intersecting curves or in areas where multiple lines create enclosed spaces.");
            }
        }
        function calculateEnergy(dataArray) {
            let totalEnergy = 0;
            
            // Using trapezoidal rule for integration
            for (let i = 0; i < dataArray.length - 1; i++) {
                const timeStep = 1; // 1 hour intervals
                const avgPower = (dataArray[i] + dataArray[i + 1]) / 2;
                totalEnergy += avgPower * timeStep; // kW * hours = kWh
            }
            
            return totalEnergy;
        }
        function showDifferencePopup() {
            const point1 = selectedPoints[0];
            const point2 = selectedPoints[1];
            const pointDifference = Math.abs(point2.y - point1.y);
            
            // Get the full data arrays for both series
            const series1Data = data[point1.seriesName];
            const series2Data = data[point2.seriesName];
            
            // Calculate total energy for each series
            const energy1 = calculateEnergy(series1Data);
            const energy2 = calculateEnergy(series2Data);
            const energyDifference = Math.abs(energy2 - energy1);
            
            const content = `
                <h3>Load Difference & Energy Analysis</h3>
                <p><strong>Time:</strong> ${point1.x}:00 hours</p>
                
                <h4>Point Comparison:</h4>
                <p><strong>Point 1:</strong> ${point1.seriesName} = ${point1.y.toFixed(1)} kW</p>
                <p><strong>Point 2:</strong> ${point2.seriesName} = ${point2.y.toFixed(1)} kW</p>
                <p><strong>Point Difference:</strong> ${pointDifference.toFixed(1)} kW</p>
                
                <hr>
                
                <h4>24-Hour Energy Analysis:</h4>
                <p><strong>${point1.seriesName}:</strong> ${energy1.toFixed(1)} kWh</p>
                <p><strong>${point2.seriesName}:</strong> ${energy2.toFixed(1)} kWh</p>
                <p><strong>Energy Difference:</strong> ${energyDifference.toFixed(1)} kWh</p>
                
            `;
            
            document.getElementById('popup-content').innerHTML = content;
            document.getElementById('popup-overlay').style.display = 'block';
            
            selectedPoints = []; // Reset selection
        }
        
        function closePopup() {
            document.getElementById('popup-overlay').style.display = 'none';
            areaPopupVisible = false;
            selectedAreaPoints = [];
        }
        function findAllIntersections() {
            const intersections = [];
            const visibleSeries = getVisibleSeries();
            
            // Find intersections between all pairs of visible series
            for (let i = 0; i < visibleSeries.length; i++) {
                for (let j = i + 1; j < visibleSeries.length; j++) {
                    const series1 = visibleSeries[i];
                    const series2 = visibleSeries[j];
                    const seriesIntersections = findIntersectionsBetweenSeries(data[series1], data[series2], data.time);
                    
                    seriesIntersections.forEach(intersection => {
                        intersections.push({
                            ...intersection,
                            series1: series1,
                            series2: series2
                        });
                    });
                }
            }
            
            // Add boundary intersections (start and end of time range)
            // This helps create regions at the edges
            const timeStart = data.time[0];
            const timeEnd = data.time[data.time.length - 1];
            
            visibleSeries.forEach((series, i) => {
                visibleSeries.slice(i + 1).forEach(otherSeries => {
                    // Add start point intersection if curves are different
                    const startY1 = data[series][0];
                    const startY2 = data[otherSeries][0];
                    if (Math.abs(startY1 - startY2) > 1) {
                        intersections.push({
                            x: timeStart,
                            y: Math.min(startY1, startY2),
                            timeIndex: 0,
                            series1: series,
                            series2: otherSeries,
                            isBoundary: true
                        });
                    }
                    
                    // Add end point intersection if curves are different
                    const endIndex = data[series].length - 1;
                    const endY1 = data[series][endIndex];
                    const endY2 = data[otherSeries][endIndex];
                    if (Math.abs(endY1 - endY2) > 1) {
                        intersections.push({
                            x: timeEnd,
                            y: Math.min(endY1, endY2),
                            timeIndex: endIndex,
                            series1: series,
                            series2: otherSeries,
                            isBoundary: true
                        });
                    }
                });
            });

            return intersections.sort((a, b) => a.x - b.x);
        }
        
        function findIntersectionsBetweenSeries(series1Data, series2Data, timeData) {
            const intersections = [];
            const tolerance = 0.1; // Tolerance for considering lines "equal"
            
            for (let i = 0; i < series1Data.length - 1; i++) {
                const x1 = timeData[i];
                const x2 = timeData[i + 1];
                const y1_s1 = series1Data[i];
                const y2_s1 = series1Data[i + 1];
                const y1_s2 = series2Data[i];
                const y2_s2 = series2Data[i + 1];
                
                // Check if lines intersect (different signs of difference)
                const diff1 = y1_s1 - y1_s2;
                const diff2 = y2_s1 - y2_s2;
                
                // Skip if lines are too close (parallel/same)
                if (Math.abs(diff1) <= tolerance && Math.abs(diff2) <= tolerance) {
                    continue;
                }
                
                // Check for intersection
                if (Math.abs(diff1) > tolerance && Math.abs(diff2) > tolerance && diff1 * diff2 < 0) {
                    // Linear interpolation to find intersection point
                    const t = Math.abs(diff1) / (Math.abs(diff1) + Math.abs(diff2));
                    const intersectX = x1 + t * (x2 - x1);
                    const intersectY = y1_s1 + t * (y2_s1 - y1_s1);
                    
                    intersections.push({
                        x: intersectX,
                        y: intersectY,
                        timeIndex: i + t
                    });
                }
                
                // Also check if one line crosses the other at endpoints
                if (Math.abs(diff1) <= tolerance && Math.abs(diff2) > tolerance) {
                    intersections.push({
                        x: x1,
                        y: y1_s1,
                        timeIndex: i
                    });
                }
                if (Math.abs(diff2) <= tolerance && Math.abs(diff1) > tolerance) {
                    intersections.push({
                        x: x2,
                        y: y2_s1,
                        timeIndex: i + 1
                    });
                }
            }
            
            return intersections;
        }
        
        function getVisibleSeries() {
            const visible = [];
            Object.keys(data).forEach(seriesName => {
                if (seriesName !== 'time') {
                    // Try to find corresponding checkbox
                    const possibleIds = [
                        seriesName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                        seriesName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''),
                        seriesName.replace(/\s+/g, '-').toLowerCase()
                    ];
                    
                    for (let id of possibleIds) {
                        const checkbox = document.getElementById(id);
                        if (checkbox && checkbox.checked) {
                            visible.push(seriesName);
                            break;
                        }
                    }
                }
            });
            return visible;
        }
        
        function getSeriesValueAtX(seriesData, timeData, targetX) {
            // Find the closest time points
            for (let i = 0; i < timeData.length - 1; i++) {
                if (timeData[i] <= targetX && targetX <= timeData[i + 1]) {
                    // Linear interpolation
                    const t = (targetX - timeData[i]) / (timeData[i + 1] - timeData[i]);
                    return seriesData[i] + t * (seriesData[i + 1] - seriesData[i]);
                }
            }
            return null;
        }
        
        function findEnclosingRegion(clickX, clickY) {
            const allIntersections = findAllIntersections();
            const visibleSeries = getVisibleSeries();
            const tolerance = 20; // kW tolerance for Y-coordinate matching
            
            if (visibleSeries.length < 2) {
                return null;
            }
            
            // Get all series values at the click X position
            const seriesAtClick = [];
            visibleSeries.forEach(seriesName => {
                const value = getSeriesValueAtX(data[seriesName], data.time, clickX);
                if (value !== null) {
                    seriesAtClick.push({ name: seriesName, value: value });
                }
            });
            
            // Sort by value to find which curves the click is between
            seriesAtClick.sort((a, b) => a.value - b.value);
            
            // Find which two curves the click is between
            let lowerSeries = null;
            let upperSeries = null;
            
            for (let i = 0; i < seriesAtClick.length - 1; i++) {
                const lower = seriesAtClick[i];
                const upper = seriesAtClick[i + 1];
                
                if (lower.value <= clickY + tolerance && clickY - tolerance <= upper.value) {
                    lowerSeries = lower.name;
                    upperSeries = upper.name;
                    break;
                }
            }
            
            if (!lowerSeries || !upperSeries) {
                return null;
            }
            
            // Find reasonable X boundaries (look for significant separation)
            let startX = Math.max(0, clickX - 4); // Start 4 hours before click or at beginning
            let endX = Math.min(24, clickX + 4);  // End 4 hours after click or at end
            
            // Try to find better boundaries based on intersections
            const relevantIntersections = allIntersections.filter(intersection => 
                (intersection.series1 === lowerSeries && intersection.series2 === upperSeries) ||
                (intersection.series1 === upperSeries && intersection.series2 === lowerSeries)
            );
            
            if (relevantIntersections.length >= 2) {
                // Use actual intersections as boundaries
                const beforeClick = relevantIntersections.filter(i => i.x <= clickX);
                const afterClick = relevantIntersections.filter(i => i.x >= clickX);
                
                if (beforeClick.length > 0) {
                    startX = beforeClick[beforeClick.length - 1].x;
                }
                if (afterClick.length > 0) {
                    endX = afterClick[0].x;
                }
            }
            
            return {
                lowerSeries: lowerSeries,
                upperSeries: upperSeries,
                startX: startX,
                endX: endX
            };
        }
        
        function calculateEnclosedArea(region) {
            const { lowerSeries, upperSeries, startX, endX } = region;
            const lowerData = data[lowerSeries];
            const upperData = data[upperSeries];
            const timeData = data.time;
            
            let area = 0;
            const step = 0.01; // High resolution for accuracy
            
            for (let x = startX; x < endX; x += step) {
                const lowerY = getSeriesValueAtX(lowerData, timeData, x);
                const upperY = getSeriesValueAtX(upperData, timeData, x);
                
                if (lowerY !== null && upperY !== null) {
                    area += Math.abs(upperY - lowerY) * step;
                }
            }
            
            return area;
        }
        
        function handleRegionClick(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // Fallback to old behavior or show message
                alert("No enclosed region found at this location. Try clicking between intersecting curves.");
            }
        }
        
        function showRegionPopup(region, area) {
            const content = `
                <h3>Enclosed Region Area</h3>
                <p><strong>Time Range:</strong> ${region.startX.toFixed(2)} - ${region.endX.toFixed(2)} hours</p>
                <p><strong>Upper Boundary:</strong> ${region.upperSeries}</p>
                <p><strong>Lower Boundary:</strong> ${region.lowerSeries}</p>
                <p><strong>Enclosed Area:</strong> ${area.toFixed(1)} kWh</p>
                <p><em>Click another region to calculate new area</em></p>
            `;
            
            document.getElementById('popup-content').innerHTML = content;
            document.getElementById('popup-overlay').style.display = 'block';
            areaPopupVisible = true;
        }
        function updateLegendWithEnergy() {
            // Calculate and display energy for all visible series
            Object.keys(data).forEach(seriesName => {
                if (seriesName !== 'time') {
                    const energy = calculateEnergy(data[seriesName]);
                    console.log(`${seriesName}: ${energy.toFixed(1)} kWh`);
                }
            });
        }
        
        // Configuration for different groups
        const groups = {
            load: {
                color: ['#228B22', '#32CD32'], // Green tones
                series: ['Present Load', 'Predicted Load'],
                mode: 'markers+lines',
                symbols: ['circle', 'square'],
                ids: ['present-load', 'predicted-load']
            },
			solar: {
				color: ['#FF8C00', '#FFA500', '#FF6347', '#DC143C'], // Orange/Red tones - ADD FOURTH COLOR
				series: ['Solar Power', 'Solar Power 2', 'Diesel Demand', 'Diesel Demand 2'], // ADD BOTH NEW SERIES
				mode: 'markers+lines',
				symbols: ['diamond', 'star', 'triangle-up', 'triangle-down'], // ADD 'star' AND 'triangle-down'
				ids: ['solar-power', 'solar-power-2', 'diesel-demand', 'diesel-demand-2'] // ADD BOTH NEW IDS
			},
			current: {
				color: ['#4169E1', '#1E90FF', '#00BFFF', '#87CEEB', '#6660ED', '#B0C4DE', '#4682B4', '#20B2AA', '#5F9EA0'], // Extended blue tones - ADD TWO MORE COLORS
				series: ['650+460', '650', '650+160', '650+508', '508+160', '508+460', '460+160', '460', '160', '508'],  // ADD '650+508' AND '508+460'
				mode: 'lines',
				dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash', 'longdashdot', '5,5,1,5', '10,5', '2,2,10,2'], // ADD TWO MORE DASH STYLES
				ids: ['650-460', '650', '650-160', '650-508', '508-160', '508-460', '460-160', '460', '160', '508']  // ADD '650-508' AND '508-460'
			}
            '200kW': {
                color: ['#DC143C', '#B22222', '#FF1493', '#C71585', '#8B0000'], // Red/Pink tones
                series: ['460+200(VP)', '650+200(VP)', '160+200(VP)', '508+200(VP)', '200kW'],
                mode: 'lines+markers',
                dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash'],
                ids: ['460-200vp', '650-200vp', '160-200vp', '508-200vp', '200kW']
            },
            '520kW': {
                color: ['#9370DB', '#8A2BE2', '#9932CC', '#BA55D3', '#4B0082'], // Purple tones
                series: ['460+520(VP)', '650+520(VP)', '160+520(VP)', '508+520(VP)', '520kW'],
                mode: 'lines+markers',
                dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash'],
                ids: ['460-520vp', '650-520vp', '160-520vp', '508-520vp', '520kW']
            }
        };

        function createPlot() {
            const traces = [];
            
            Object.keys(groups).forEach(groupKey => {
                const group = groups[groupKey];
                group.series.forEach((seriesName, index) => {
                    const checkbox = document.getElementById(group.ids[index]);
                    
                    if (checkbox && checkbox.checked) {
                        const trace = {
                            x: data.time,
                            y: data[seriesName],
                            name: seriesName,
                            type: 'scatter',
                            mode: group.mode,
                            line: {
                                color: group.color[index],
                                width: 2
                            },
                            marker: {
                                color: group.color[index],
                                size: 6
                            }
                        };

                        if (group.symbols) {
                            trace.marker.symbol = group.symbols[index];
                        }

                        if (group.dash) {
                            trace.line.dash = group.dash[index];
                        }

                        traces.push(trace);
                    }
                });
            });

            const layout = {
                title: {
                    text: 'Summer Island Load Variation',
                    font: { size: 20 }
                },
                xaxis: {
                    title: 'Time (hr)',
                    gridcolor: '#e6e6e6',
                    tick0: 0,
                    dtick: 1,
                    range: [0, 24]
                },
                yaxis: {
                    title: 'Load (kW)',
                    gridcolor: '#e6e6e6'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                legend: {
                    x: 1.02,
                    y: 1,
                    orientation: 'v'
                },
                margin: {
                    l: 80,
                    r: 150,
                    t: 60,
                    b: 60
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'toggleSpikelines'],
                displaylogo: false
            };

            Plotly.newPlot('plot', traces, layout, config);
            
            addClickListener();
        }

        function toggleGroup(groupName) {
            const items = document.getElementById(groupName + '-items');
            if (items.style.display === 'none') {
                items.style.display = 'block';
            } else {
                items.style.display = 'none';
            }
        }

        function toggleGroupSelection(groupName) {
            const groupCheckbox = document.getElementById('group-' + groupName);
            const itemCheckboxes = document.querySelectorAll('.group-' + groupName);
            
            itemCheckboxes.forEach(cb => {
                cb.checked = groupCheckbox.checked;
            });
            
            createPlot();
        }

        function updateGroupCheckbox(groupName) {
            const itemCheckboxes = document.querySelectorAll('.group-' + groupName);
            const groupCheckbox = document.getElementById('group-' + groupName);
            
            const checkedCount = Array.from(itemCheckboxes).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = false;
            } else if (checkedCount === itemCheckboxes.length) {
                groupCheckbox.checked = true;
                groupCheckbox.indeterminate = false;
            } else {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = true;
            }
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            createPlot();
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            createPlot();
        }

        // Add event listeners to all checkboxes
        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]:not([id^="group-"])');
			// Add load slider listener
			document.getElementById('load-slider').addEventListener('input', updateLoadSlider);

			// Initialize generator data with default 75% load
			updateGeneratorData(75);
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // Update group checkbox state
                    const groups = ['load', 'solar', 'current', '200kW', '520kW'];
                    groups.forEach(groupName => {
                        if (checkbox.classList.contains('group-' + groupName)) {
                            updateGroupCheckbox(groupName);
                        }
                    });
                    createPlot();
                });
            });
            
            // Initial plot
            createPlot();
            // Add mode change listeners
            document.getElementById('mode-points').addEventListener('change', updateInteractionMode);
            document.getElementById('mode-area').addEventListener('change', updateInteractionMode);
        });
    </script>
</body>
</html>
