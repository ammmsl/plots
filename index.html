<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Summer Island Load Variation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.24.1/plotly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            gap: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            width: 250px;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .plot-container {
            flex: 1;
            min-height: 600px;
        }
        .group {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        .group-header {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            cursor: pointer;
            user-select: none;
        }
        .group-header:hover {
            color: #007bff;
        }
        .group-items {
            margin-left: 10px;
        }
        .checkbox-item {
            margin: 5px 0;
        }
        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
        }
        .checkbox-item label {
            cursor: pointer;
            font-size: 14px;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .select-all-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }
        .select-all-btn:hover {
            background-color: #0056b3;
        }
        .deselect-all-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .deselect-all-btn:hover {
            background-color: #545b62;
        }
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
        }
        
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 400px;
            max-width: 500px;
            z-index: 1001;
        }
        
        .popup h3, .popup h4 {
            margin-top: 0;
            color: #333;
        }
        
        .popup hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 15px 0;
        }
        
        .popup p {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .popup-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        
        .popup-close:hover {
            color: #000;
        }
        
    </style>
</head>
<body>
<!--     <h1>Summer Island Load Variation</h1> -->
    <div class="container">
        <div class="controls">
            <div style="margin-bottom: 15px;">
                <button class="select-all-btn" onclick="selectAll()">Select All</button>
                <button class="deselect-all-btn" onclick="deselectAll()">Deselect All</button>
            </div>
        <div style="margin-bottom: 15px; border-top: 1px solid #ddd; padding-top: 10px;">
            <label style="font-weight: bold; margin-bottom: 5px; display: block;">Interaction Mode:</label>
            <input type="radio" id="mode-points" name="interaction-mode" value="points" checked>
            <label for="mode-points" style="margin-right: 15px;">Point Comparison</label>
            <input type="radio" id="mode-area" name="interaction-mode" value="area">
            <label for="mode-area">Area Calculation</label>
        </div>            
            <div class="group">
                <div class="group-header" onclick="toggleGroup('load')">
                    <input type="checkbox" id="group-load" onchange="toggleGroupSelection('load')" checked>
                    üìä Load
                </div>
                <div class="group-items" id="load-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="present-load" class="group-load" checked>
                        <label for="present-load">Present Load</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="predicted-load" class="group-load" checked>
                        <label for="predicted-load">Predicted Load</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('solar')">
                    <input type="checkbox" id="group-solar" onchange="toggleGroupSelection('solar')" checked>
                    ‚òÄÔ∏è Solar
                </div>
                <div class="group-items" id="solar-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="solar-power" class="group-solar" checked>
                        <label for="solar-power">Solar Power</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="diesel-demand" class="group-solar" checked>
                        <label for="diesel-demand">Diesel Demand</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('current')">
                    <input type="checkbox" id="group-current" onchange="toggleGroupSelection('current')">
                    üîß Current Configurations
                </div>
                <div class="group-items" id="current-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="810-575-75" class="group-current">
                        <label for="810-575-75">810+575 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="810-200-75" class="group-current">
                        <label for="810-200-75">810+200 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="200-638-75" class="group-current">
                        <label for="200-638-75">200+638 75%</label>
                    </div>                    
                    <div class="checkbox-item">
                        <input type="checkbox" id="810-75" class="group-current">
                        <label for="810-75">810 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="638-75" class="group-current">
                        <label for="638-75">638 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="575-75" class="group-current">
                        <label for="575-75">575 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="200-75" class="group-current">
                        <label for="200-75">200 75%</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('250kva')">
                    <input type="checkbox" id="group-250kva" onchange="toggleGroupSelection('250kva')">
                    ‚ö° 250kVA Unit
                </div>
                <div class="group-items" id="250kva-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="810-250vp-75" class="group-250kva">
                        <label for="810-250vp-75">810+250(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="638-250vp-75" class="group-250kva">
                        <label for="638-250vp-75">638+250(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="575-250vp-75" class="group-250kva">
                        <label for="575-250vp-75">575+250(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="200-250vp-75" class="group-250kva">
                        <label for="200-250vp-75">200+250(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="250kva-75" class="group-250kva">
                        <label for="250kva-75">250kVA 75%</label>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="group-header" onclick="toggleGroup('650kva')">
                    <input type="checkbox" id="group-650kva" onchange="toggleGroupSelection('650kva')">
                    ‚ö° 650kVA Unit
                </div>
                <div class="group-items" id="650kva-items">
                    <div class="checkbox-item">
                        <input type="checkbox" id="810-650vp-75" class="group-650kva">
                        <label for="810-650vp-75">810+650(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="638-650vp-75" class="group-650kva">
                        <label for="638-650vp-75">638+650(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="575-650vp-75" class="group-650kva">
                        <label for="575-650vp-75">575+650(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="200-650vp-75" class="group-650kva">
                        <label for="200-650vp-75">200+650(VP) 75%</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="650kva-75" class="group-650kva">
                        <label for="650kva-75">650kVA 75%</label>
                    </div>
                </div>
            </div>
        </div>

        <div class="plot-container">
            <div id="plot" style="width: 100%; height: 600px;"></div>
        </div>
        <div id="popup-overlay" class="popup-overlay" onclick="closePopup()">
            <div class="popup" onclick="event.stopPropagation()">
                <button class="popup-close" onclick="closePopup()">&times;</button>
                <div id="popup-content"></div>
            </div>
        </div>
    </div>

    <script>
        // Data
        const data = {
            time: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],
            'Present Load': [230, 237.1555765, 258.1346652, 291.507576, 335, 385.6480005, 440, 494.3519995, 545, 588.492424, 621.8653348, 642.8444235, 650, 642.8444235, 621.8653348, 588.492424, 545, 494.3519995, 440, 385.6480005, 335, 291.507576, 258.1346652, 237.1555765, 230],
            'Predicted Load': [272.728913,264.5,272.728913,296.854865,335.2337123,385.25,443.4952006,506,568.5047994,626.75,676.7662877,715.145135,739.271087,747.5,739.271087,715.145135,676.7662877,626.75,568.5047994,506,443.4952006,385.25,335.2337123,296.854865,272.728913],
            'Solar Power': [0,0,0,0,0,0,0,182.8401262,353.22,499.5285145,611.7949862,682.3686407,706.44,682.3686407,611.7949862,499.5285145,353.22,182.8401262,8.65494E-14,0,0,0,0,0,0],
            'Diesel Demand': [237.2,230.0,237.2,258.1,291.5,335.0,385.6,257.2,141.1,45.5,-23.3,-60.5,-63.6,-32.4,31.0,122.3,235.3,362.2,494.4,440.0,385.6,335.0,291.5,258.1,237.2],
            '810+575 75%': [833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833,833],
            '810 75%': [488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488,488],
            '810+200 75%': [608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608,608],
            '200+638 75%': [501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501,501],
            '575 75%': [345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345,345],
            '200 75%': [120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120],
            '638 75%': [381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381,381],
            '250kVA 75%': [150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150],
            '650kVA 75%': [390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390],
            '575+250(VP) 75%': [495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495,495],
            '810+250(VP) 75%': [638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638,638],
            '200+250(VP) 75%': [270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270,270],
            '638+250(VP) 75%': [531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531,531],
            '575+650(VP) 75%': [735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735,735],
            '810+650(VP) 75%': [878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878,878],
            '200+650(VP) 75%': [510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510,510],
            '638+650(VP) 75%': [771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771,771]
        };
        data['Predicted Load'] = data['Present Load'].map(load => load * 1.15);
        data['Diesel Demand'] = data['Present Load'].map((load, index) => load - data['Solar Power'][index]);
        let selectedPoints = [];
        let selectedAreaPoints = [];
        let areaPopupVisible = false;        
        let interactionMode = 'points'; // Default mode
        
        // Add mode change listener
        function updateInteractionMode() {
            const pointsMode = document.getElementById('mode-points');
            const areaMode = document.getElementById('mode-area');
            
            if (pointsMode.checked) {
                interactionMode = 'points';
            } else if (areaMode.checked) {
                interactionMode = 'area';
            }
            
            // Reset selections when mode changes
            selectedPoints = [];
            selectedAreaPoints = [];
            closePopup();
        }
        // Add event listener after plot creation
        function addClickListener() {
            document.getElementById('plot').on('plotly_click', handlePlotClick);
        }
        
        function handlePlotClick(data) {
            const point = data.points[0];
            const clickedPoint = {
                x: point.x,
                y: point.y,
                seriesName: point.data.name
            };
            
            if (interactionMode === 'points') {
                handlePointSelection(clickedPoint);
            } else if (interactionMode === 'area') {
                handleAreaSelection(data);
            }
        }
        
        function handlePointSelection(clickedPoint) {
            selectedPoints.push(clickedPoint);
            
            if (selectedPoints.length === 2) {
                // Check if both points have same x value for point difference
                if (selectedPoints[0].x === selectedPoints[1].x) {
                    showDifferencePopup();
                } else {
                    // Show message that points need same X coordinate
                    alert("For point comparison, please select two points at the same time (X-coordinate). Selected points will be reset.");
                    selectedPoints = []; // Reset selection
                }
            } else if (selectedPoints.length > 2) {
                selectedPoints = [clickedPoint]; // Start new selection
            }
        }
        
        function handleAreaSelection(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // More helpful error message
                alert("No enclosed region found. Try clicking between intersecting curves or in areas where multiple lines create enclosed spaces.");
            }
        }
        
        function handlePointSelection(clickedPoint) {
            selectedPoints.push(clickedPoint);
            
            if (selectedPoints.length === 2) {
                // Check if both points have same x value for point difference
                if (selectedPoints[0].x === selectedPoints[1].x) {
                    showDifferencePopup();
                } else {
                    // Show message that points need same X coordinate
                    alert("For point comparison, please select two points at the same time (X-coordinate). Selected points will be reset.");
                    selectedPoints = []; // Reset selection
                }
            } else if (selectedPoints.length > 2) {
                selectedPoints = [clickedPoint]; // Start new selection
            }
        }
        
        function handleAreaSelection(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // More helpful error message
                alert("No enclosed region found. Try clicking between intersecting curves or in areas where multiple lines create enclosed spaces.");
            }
        }
        function calculateEnergy(dataArray) {
            let totalEnergy = 0;
            
            // Using trapezoidal rule for integration
            for (let i = 0; i < dataArray.length - 1; i++) {
                const timeStep = 1; // 1 hour intervals
                const avgPower = (dataArray[i] + dataArray[i + 1]) / 2;
                totalEnergy += avgPower * timeStep; // kW * hours = kWh
            }
            
            return totalEnergy;
        }
        function showDifferencePopup() {
            const point1 = selectedPoints[0];
            const point2 = selectedPoints[1];
            const pointDifference = Math.abs(point2.y - point1.y);
            
            // Get the full data arrays for both series
            const series1Data = data[point1.seriesName];
            const series2Data = data[point2.seriesName];
            
            // Calculate total energy for each series
            const energy1 = calculateEnergy(series1Data);
            const energy2 = calculateEnergy(series2Data);
            const energyDifference = Math.abs(energy2 - energy1);
            
            const content = `
                <h3>Load Difference & Energy Analysis</h3>
                <p><strong>Time:</strong> ${point1.x}:00 hours</p>
                
                <h4>Point Comparison:</h4>
                <p><strong>Point 1:</strong> ${point1.seriesName} = ${point1.y.toFixed(1)} kW</p>
                <p><strong>Point 2:</strong> ${point2.seriesName} = ${point2.y.toFixed(1)} kW</p>
                <p><strong>Point Difference:</strong> ${pointDifference.toFixed(1)} kW</p>
                
                <hr>
                
                <h4>24-Hour Energy Analysis:</h4>
                <p><strong>${point1.seriesName}:</strong> ${energy1.toFixed(1)} kWh</p>
                <p><strong>${point2.seriesName}:</strong> ${energy2.toFixed(1)} kWh</p>
                <p><strong>Energy Difference:</strong> ${energyDifference.toFixed(1)} kWh</p>
                
            `;
            
            document.getElementById('popup-content').innerHTML = content;
            document.getElementById('popup-overlay').style.display = 'block';
            
            selectedPoints = []; // Reset selection
        }
        
        function closePopup() {
            document.getElementById('popup-overlay').style.display = 'none';
            areaPopupVisible = false;
            selectedAreaPoints = [];
        }
        function findAllIntersections() {
            const intersections = [];
            const visibleSeries = getVisibleSeries();
            
            // Find intersections between all pairs of visible series
            for (let i = 0; i < visibleSeries.length; i++) {
                for (let j = i + 1; j < visibleSeries.length; j++) {
                    const series1 = visibleSeries[i];
                    const series2 = visibleSeries[j];
                    const seriesIntersections = findIntersectionsBetweenSeries(data[series1], data[series2], data.time);
                    
                    seriesIntersections.forEach(intersection => {
                        intersections.push({
                            ...intersection,
                            series1: series1,
                            series2: series2
                        });
                    });
                }
            }
            
            // Add boundary intersections (start and end of time range)
            // This helps create regions at the edges
            const timeStart = data.time[0];
            const timeEnd = data.time[data.time.length - 1];
            
            visibleSeries.forEach((series, i) => {
                visibleSeries.slice(i + 1).forEach(otherSeries => {
                    // Add start point intersection if curves are different
                    const startY1 = data[series][0];
                    const startY2 = data[otherSeries][0];
                    if (Math.abs(startY1 - startY2) > 1) {
                        intersections.push({
                            x: timeStart,
                            y: Math.min(startY1, startY2),
                            timeIndex: 0,
                            series1: series,
                            series2: otherSeries,
                            isBoundary: true
                        });
                    }
                    
                    // Add end point intersection if curves are different
                    const endIndex = data[series].length - 1;
                    const endY1 = data[series][endIndex];
                    const endY2 = data[otherSeries][endIndex];
                    if (Math.abs(endY1 - endY2) > 1) {
                        intersections.push({
                            x: timeEnd,
                            y: Math.min(endY1, endY2),
                            timeIndex: endIndex,
                            series1: series,
                            series2: otherSeries,
                            isBoundary: true
                        });
                    }
                });
            });

            return intersections.sort((a, b) => a.x - b.x);
        }
        
        function findIntersectionsBetweenSeries(series1Data, series2Data, timeData) {
            const intersections = [];
            const tolerance = 0.1; // Tolerance for considering lines "equal"
            
            for (let i = 0; i < series1Data.length - 1; i++) {
                const x1 = timeData[i];
                const x2 = timeData[i + 1];
                const y1_s1 = series1Data[i];
                const y2_s1 = series1Data[i + 1];
                const y1_s2 = series2Data[i];
                const y2_s2 = series2Data[i + 1];
                
                // Check if lines intersect (different signs of difference)
                const diff1 = y1_s1 - y1_s2;
                const diff2 = y2_s1 - y2_s2;
                
                // Skip if lines are too close (parallel/same)
                if (Math.abs(diff1) <= tolerance && Math.abs(diff2) <= tolerance) {
                    continue;
                }
                
                // Check for intersection
                if (Math.abs(diff1) > tolerance && Math.abs(diff2) > tolerance && diff1 * diff2 < 0) {
                    // Linear interpolation to find intersection point
                    const t = Math.abs(diff1) / (Math.abs(diff1) + Math.abs(diff2));
                    const intersectX = x1 + t * (x2 - x1);
                    const intersectY = y1_s1 + t * (y2_s1 - y1_s1);
                    
                    intersections.push({
                        x: intersectX,
                        y: intersectY,
                        timeIndex: i + t
                    });
                }
                
                // Also check if one line crosses the other at endpoints
                if (Math.abs(diff1) <= tolerance && Math.abs(diff2) > tolerance) {
                    intersections.push({
                        x: x1,
                        y: y1_s1,
                        timeIndex: i
                    });
                }
                if (Math.abs(diff2) <= tolerance && Math.abs(diff1) > tolerance) {
                    intersections.push({
                        x: x2,
                        y: y2_s1,
                        timeIndex: i + 1
                    });
                }
            }
            
            return intersections;
        }
        
        function getVisibleSeries() {
            const visible = [];
            Object.keys(data).forEach(seriesName => {
                if (seriesName !== 'time') {
                    // Try to find corresponding checkbox
                    const possibleIds = [
                        seriesName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                        seriesName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''),
                        seriesName.replace(/\s+/g, '-').toLowerCase()
                    ];
                    
                    for (let id of possibleIds) {
                        const checkbox = document.getElementById(id);
                        if (checkbox && checkbox.checked) {
                            visible.push(seriesName);
                            break;
                        }
                    }
                }
            });
            return visible;
        }
        
        function getSeriesValueAtX(seriesData, timeData, targetX) {
            // Find the closest time points
            for (let i = 0; i < timeData.length - 1; i++) {
                if (timeData[i] <= targetX && targetX <= timeData[i + 1]) {
                    // Linear interpolation
                    const t = (targetX - timeData[i]) / (timeData[i + 1] - timeData[i]);
                    return seriesData[i] + t * (seriesData[i + 1] - seriesData[i]);
                }
            }
            return null;
        }
        
        function findEnclosingRegion(clickX, clickY) {
            const allIntersections = findAllIntersections();
            const visibleSeries = getVisibleSeries();
            const tolerance = 20; // kW tolerance for Y-coordinate matching
            
            if (visibleSeries.length < 2) {
                return null;
            }
            
            // Get all series values at the click X position
            const seriesAtClick = [];
            visibleSeries.forEach(seriesName => {
                const value = getSeriesValueAtX(data[seriesName], data.time, clickX);
                if (value !== null) {
                    seriesAtClick.push({ name: seriesName, value: value });
                }
            });
            
            // Sort by value to find which curves the click is between
            seriesAtClick.sort((a, b) => a.value - b.value);
            
            // Find which two curves the click is between
            let lowerSeries = null;
            let upperSeries = null;
            
            for (let i = 0; i < seriesAtClick.length - 1; i++) {
                const lower = seriesAtClick[i];
                const upper = seriesAtClick[i + 1];
                
                if (lower.value <= clickY + tolerance && clickY - tolerance <= upper.value) {
                    lowerSeries = lower.name;
                    upperSeries = upper.name;
                    break;
                }
            }
            
            if (!lowerSeries || !upperSeries) {
                return null;
            }
            
            // Find reasonable X boundaries (look for significant separation)
            let startX = Math.max(0, clickX - 4); // Start 4 hours before click or at beginning
            let endX = Math.min(24, clickX + 4);  // End 4 hours after click or at end
            
            // Try to find better boundaries based on intersections
            const relevantIntersections = allIntersections.filter(intersection => 
                (intersection.series1 === lowerSeries && intersection.series2 === upperSeries) ||
                (intersection.series1 === upperSeries && intersection.series2 === lowerSeries)
            );
            
            if (relevantIntersections.length >= 2) {
                // Use actual intersections as boundaries
                const beforeClick = relevantIntersections.filter(i => i.x <= clickX);
                const afterClick = relevantIntersections.filter(i => i.x >= clickX);
                
                if (beforeClick.length > 0) {
                    startX = beforeClick[beforeClick.length - 1].x;
                }
                if (afterClick.length > 0) {
                    endX = afterClick[0].x;
                }
            }
            
            return {
                lowerSeries: lowerSeries,
                upperSeries: upperSeries,
                startX: startX,
                endX: endX
            };
        }
        
        function calculateEnclosedArea(region) {
            const { lowerSeries, upperSeries, startX, endX } = region;
            const lowerData = data[lowerSeries];
            const upperData = data[upperSeries];
            const timeData = data.time;
            
            let area = 0;
            const step = 0.01; // High resolution for accuracy
            
            for (let x = startX; x < endX; x += step) {
                const lowerY = getSeriesValueAtX(lowerData, timeData, x);
                const upperY = getSeriesValueAtX(upperData, timeData, x);
                
                if (lowerY !== null && upperY !== null) {
                    area += Math.abs(upperY - lowerY) * step;
                }
            }
            
            return area;
        }
        
        function handleRegionClick(clickData) {
            const point = clickData.points[0];
            const clickX = point.x;
            const clickY = point.y;
            
            const region = findEnclosingRegion(clickX, clickY);
            
            if (region) {
                const area = calculateEnclosedArea(region);
                showRegionPopup(region, area);
            } else {
                // Fallback to old behavior or show message
                alert("No enclosed region found at this location. Try clicking between intersecting curves.");
            }
        }
        
        function showRegionPopup(region, area) {
            const content = `
                <h3>Enclosed Region Area</h3>
                <p><strong>Time Range:</strong> ${region.startX.toFixed(2)} - ${region.endX.toFixed(2)} hours</p>
                <p><strong>Upper Boundary:</strong> ${region.upperSeries}</p>
                <p><strong>Lower Boundary:</strong> ${region.lowerSeries}</p>
                <p><strong>Enclosed Area:</strong> ${area.toFixed(1)} kWh</p>
                <p><em>Click another region to calculate new area</em></p>
            `;
            
            document.getElementById('popup-content').innerHTML = content;
            document.getElementById('popup-overlay').style.display = 'block';
            areaPopupVisible = true;
        }
        function updateLegendWithEnergy() {
            // Calculate and display energy for all visible series
            Object.keys(data).forEach(seriesName => {
                if (seriesName !== 'time') {
                    const energy = calculateEnergy(data[seriesName]);
                    console.log(`${seriesName}: ${energy.toFixed(1)} kWh`);
                }
            });
        }
        
        // Configuration for different groups
        const groups = {
            load: {
                color: ['#228B22', '#32CD32'], // Green tones
                series: ['Present Load', 'Predicted Load'],
                mode: 'markers+lines',
                symbols: ['circle', 'square'],
                ids: ['present-load', 'predicted-load']
            },
            solar: {
                color: ['#FF8C00', '#FF6347'], // Orange tones
                series: ['Solar Power', 'Diesel Demand'],
                mode: 'markers+lines',
                symbols: ['diamond', 'triangle-up'],
                ids: ['solar-power', 'diesel-demand']
            },
            current: {
                color: ['#4169E1', '#1E90FF', '#00BFFF', '#87CEEB', '#6495ED', '#B0C4DE', '#4682B4'], // Extended blue tones
                series: ['810+575 75%', '810 75%', '810+200 75%', '200+638 75%', '575 75%', '200 75%', '638 75%'],
                mode: 'lines',
                dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash', 'longdashdot', '5,5,1,5'],
                ids: ['810-575-75', '810-75', '810-200-75', '200-638-75', '575-75', '200-75', '638-75']
            },
            '250kva': {
                color: ['#DC143C', '#B22222', '#FF1493', '#C71585', '#8B0000'], // Red/Pink tones
                series: ['575+250(VP) 75%', '810+250(VP) 75%', '200+250(VP) 75%', '638+250(VP) 75%', '250kVA 75%'],
                mode: 'lines',
                dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash'],
                ids: ['575-250vp-75', '810-250vp-75', '200-250vp-75', '638-250vp-75', '250kva-75']
            },
            '650kva': {
                color: ['#9370DB', '#8A2BE2', '#9932CC', '#BA55D3', '#4B0082'], // Purple tones
                series: ['575+650(VP) 75%', '810+650(VP) 75%', '200+650(VP) 75%', '638+650(VP) 75%', '650kVA 75%'],
                mode: 'lines',
                dash: ['solid', 'dash', 'dot', 'dashdot', 'longdash'],
                ids: ['575-650vp-75', '810-650vp-75', '200-650vp-75', '638-650vp-75', '650kva-75']
            }
        };

        function createPlot() {
            const traces = [];
            
            Object.keys(groups).forEach(groupKey => {
                const group = groups[groupKey];
                group.series.forEach((seriesName, index) => {
                    const checkbox = document.getElementById(group.ids[index]);
                    
                    if (checkbox && checkbox.checked) {
                        const trace = {
                            x: data.time,
                            y: data[seriesName],
                            name: seriesName,
                            type: 'scatter',
                            mode: group.mode,
                            line: {
                                color: group.color[index],
                                width: 2
                            },
                            marker: {
                                color: group.color[index],
                                size: 6
                            }
                        };

                        if (group.symbols) {
                            trace.marker.symbol = group.symbols[index];
                        }

                        if (group.dash) {
                            trace.line.dash = group.dash[index];
                        }

                        traces.push(trace);
                    }
                });
            });

            const layout = {
                title: {
                    text: 'Summer Island Load Variation',
                    font: { size: 20 }
                },
                xaxis: {
                    title: 'Time (hr)',
                    gridcolor: '#e6e6e6'
                    tick0: 0,
                    dtick: 1,
                    range: [0, 24]
                },
                yaxis: {
                    title: 'Load (kW)',
                    gridcolor: '#e6e6e6'
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                legend: {
                    x: 1.02,
                    y: 1,
                    orientation: 'v'
                },
                margin: {
                    l: 80,
                    r: 150,
                    t: 60,
                    b: 60
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'toggleSpikelines'],
                displaylogo: false
            };

            Plotly.newPlot('plot', traces, layout, config);
            
            addClickListener();
        }

        function toggleGroup(groupName) {
            const items = document.getElementById(groupName + '-items');
            if (items.style.display === 'none') {
                items.style.display = 'block';
            } else {
                items.style.display = 'none';
            }
        }

        function toggleGroupSelection(groupName) {
            const groupCheckbox = document.getElementById('group-' + groupName);
            const itemCheckboxes = document.querySelectorAll('.group-' + groupName);
            
            itemCheckboxes.forEach(cb => {
                cb.checked = groupCheckbox.checked;
            });
            
            createPlot();
        }

        function updateGroupCheckbox(groupName) {
            const itemCheckboxes = document.querySelectorAll('.group-' + groupName);
            const groupCheckbox = document.getElementById('group-' + groupName);
            
            const checkedCount = Array.from(itemCheckboxes).filter(cb => cb.checked).length;
            
            if (checkedCount === 0) {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = false;
            } else if (checkedCount === itemCheckboxes.length) {
                groupCheckbox.checked = true;
                groupCheckbox.indeterminate = false;
            } else {
                groupCheckbox.checked = false;
                groupCheckbox.indeterminate = true;
            }
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            createPlot();
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            createPlot();
        }

        // Add event listeners to all checkboxes
        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]:not([id^="group-"])');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // Update group checkbox state
                    const groups = ['load', 'solar', 'current', '250kva', '650kva'];
                    groups.forEach(groupName => {
                        if (checkbox.classList.contains('group-' + groupName)) {
                            updateGroupCheckbox(groupName);
                        }
                    });
                    createPlot();
                });
            });
            
            // Initial plot
            createPlot();
            // Add mode change listeners
            document.getElementById('mode-points').addEventListener('change', updateInteractionMode);
            document.getElementById('mode-area').addEventListener('change', updateInteractionMode);
        });
    </script>
</body>
</html>
